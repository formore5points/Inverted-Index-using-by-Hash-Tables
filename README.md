# Inverted-Index-using-by-Hash-Tables
Implementation of hash table with propeties

INVERTED INDEX BY USING HASH TABLES

An inverted index is an index data structure, which is used to map all documents with their content. It keeps a word and all documents containing this word. There are two types of inverted indexes: 
	Record-level inverted index contains a list of references to documents for each word. 
	Word-level inverted index contains the positions of each word within a document. 
Inverted index allows fast full text searches and is the most popular data structure used in document retrieval systems, used on a large scale for example in search engines. Its disadvantage is large storage overhead and high maintenance costs on update, delete, and insert.
In this assignment, you are expected to implement a record-level inverted index structure using your own hash table implementation in Java programming language. Your index structure will be used to find all documents that contain a particular word (e.g., return all documents in which "computer" occurs).
To build an inverted index, you should fetch all the documents, ignore any punctuation mark, remove stop words (stop words are most the frequent ones and useless words in documents, such as “I”, “the”, “we”, “is”, “an”), and then index each document with the remaining words. The structure of the inverted index, implemented with a hash table, should look like as below:
 
Note: You are free to choose the data structure to store file references.
	Main Functionalities
	put(Key k, Value v)
If a word (k) is already present, then add a reference of the document (v) to the index; otherwise create a new entry. You should store the frequency of each word with the document identifier.

	Value get(Key k)
Search the given word (k) in the hash table. If the word is available in the table, then return an output as shown below, otherwise return a “not found” message to the user.

>Search: cat
2 documents found
3-d.txt
1-a.txt
	
> Search: dool
3 documents found
2-d.txt
1-b.txt
1-c.txt
	
> Search: ball
Not found!

	remove(Key k)
Remove the given word (k) and the associated value from the inverted index.
	resize(int capacity)
Make the hash table dynamically growable. Put method should double the current table size if the hash table reach the maximum load factor. 
# Hash Function
To specify an index corresponding to given string key, firstly you should generate an integer hash code by using a special function. Then, resulting hash code has to be converted to the range 0 to N-1 using a compression function, such as modulus operator (N is the size of hash table).
You are expected to implement two different hash functions including simple summation function and polynomial accumulation function.
	 Simple Summation Function (SSF)

You can generate the hash code of a string s with length n simply by the following formula:

h(s)=∑_(k=0)^(n-1)▒〖ch〗_k   

# Polynomial Accumulation Function (PAF)

The hash code of a string s can also be generated by using the following polynomial:

h(s)=〖〖ch〗_0*z〗^(n-1)  +〖〖ch〗_1*z〗^(n-2)  + ...+ 〖〖ch〗_(n-2)*z〗^1  + 〖〖ch〗_(n-1)*z〗^0
where 〖ch〗_0 is the left most character of the string, characters are represented as numbers in 1-26 (case insensitive), and n is the length of the string.  The constant z is usually a prime number (33, 37, 39, and 41 are particularly good choices for working English words). When the z value is chosen as 33, the string "car" has the following hash value:
h("car" )=3 * 33^2+ 1 * 33 + 18*1 = 3318

Note: Using this calculation on the long strings will result in numbers that will cause overflow.  You should ignore overflows or use Horner's rule to perform the calculation and apply the modulus operator after computing each expression in Horner's rule.
# Collision Handling

# Linear Probing (LP)
Linear probing handles collisions by placing the colliding item in the next (circularly) available table cell.
# Double Hashing (DH)
Double hashing uses a secondary hash function d(k) and handles collisions by placing an item in the first available cell of the series.
d(k)=q-k mod q
h_2 (k)=(h(k)+ j d(k))  mod N
where q < N (table size), q is a prime, and j = 0, 1, … , N – 1.
The secondary hash function d(k) cannot have zero values. The table size N must be a prime to allow probing of all the cells.
Example: 

N = 13, 
k= 31, 
q= 7, 
h(k) = k mod 13 = 5, 
d(k) = 7 - k mod 7 = 4.	The 1st lookup index: 5
The 2nd lookup index: 5+ 1*4 = 9 % 13 = 9
The 3rd lookup index: 5+2*4 = 13 % 13 = 0  
…
